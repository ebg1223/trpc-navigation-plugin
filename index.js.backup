const { Project, SyntaxKind, Node } = require('ts-morph');
const path = require('path');
const fs = require('fs');

// Immediate logging to verify plugin is loaded
console.log('[TRPC-Nav] Plugin module loaded');

function init(modules) {
  const ts = modules.typescript;
  console.log('[TRPC-Nav] Plugin init() called');
  
  function create(info) {
    const log = (...args) => info.project.projectService.logger.info(`[TRPC-Nav] ${args.join(' ')}`);
    log("Initializing TRPC Navigation Plugin");
    console.log('[TRPC-Nav] Plugin create() called');
    
    const projectRoot = findProjectRoot(info.project.getProjectName());
    let navigationMap = null;
    let lastBuildTime = 0;
    const CACHE_DURATION = 30000; // 30 seconds
    
    // Find the monorepo root
    function findProjectRoot(projectPath) {
      let current = path.dirname(projectPath);
      while (current !== path.dirname(current)) {
        if (fs.existsSync(path.join(current, 'packages', 'api', 'src', 'router'))) {
          return current;
        }
        current = path.dirname(current);
      }
      return projectPath;
    }
    
    // Build the navigation map using ts-morph
    function buildNavigationMap() {
      const startTime = Date.now();
      log("Building TRPC navigation map...");
      
      try {
        const project = new Project({
          tsConfigFilePath: path.join(projectRoot, 'packages/api/tsconfig.json'),
          skipAddingFilesFromTsConfig: true,
        });
        
        // Add only router files to the project for performance
        project.addSourceFilesAtPaths([
          path.join(projectRoot, 'packages/api/src/router/**/*.ts'),
          path.join(projectRoot, 'packages/api/src/router/index.ts')
        ]);
        
        const map = new Map();
        const routerStructure = new Map();
        
        // Step 1: Find all procedure definitions
        const procedures = new Map();
        project.getSourceFiles().forEach(sourceFile => {
          const filePath = sourceFile.getFilePath();
          
          // Skip test files and type definition files
          if (filePath.includes('.test.') || filePath.includes('.d.ts')) return;
          
          // Find all exported procedures
          sourceFile.getExportedDeclarations().forEach((declarations, name) => {
            if (name.startsWith('procedure_')) {
              declarations.forEach(decl => {
                if (Node.isVariableDeclaration(decl)) {
                  const start = decl.getStart();
                  const lineAndCol = sourceFile.getLineAndColumnAtPos(start);
                  procedures.set(name, {
                    name: name.replace('procedure_', ''),
                    filePath: filePath,
                    line: lineAndCol.line,
                    position: start,
                    length: decl.getEnd() - start
                  });
                }
              });
            }
          });
        });
        
        log(`Found ${procedures.size} procedures`);
        
        // Step 2: Build router hierarchy
        const mainRouterFile = project.getSourceFile(
          path.join(projectRoot, 'packages/api/src/router/index.ts')
        );
        
        if (!mainRouterFile) {
          log("Could not find main router file");
          return map;
        }
        
        // Find the appRouter export
        const appRouterVariable = mainRouterFile.getVariableDeclaration('appRouter');
        if (!appRouterVariable) {
          log("Could not find appRouter variable");
          return map;
        }
        
        // Trace through the router structure
        function analyzeRouter(routerNode, currentPath = [], depth = 0) {
          if (depth > 10) {
            log(`Max depth reached at path: ${currentPath.join('.')}`);
            return;
          }
          
          const initializer = routerNode.getInitializer();
          if (!initializer) {
            log(`No initializer for router at: ${currentPath.join('.')}`);
            return;
          }
          
          // Find router() call
          let routerCall = null;
          if (Node.isCallExpression(initializer) && initializer.getExpression().getText() === 'router') {
            routerCall = initializer;
          } else {
            routerCall = initializer.getDescendantsOfKind(SyntaxKind.CallExpression)
              .find(call => {
                const expr = call.getExpression();
                return expr.getText() === 'router' || expr.getText().endsWith('.router');
              });
          }
          
          if (!routerCall) {
            log(`No router call found for: ${currentPath.join('.')}`);
            return;
          }
          
          const routesArg = routerCall.getArguments()[0];
          if (!Node.isObjectLiteralExpression(routesArg)) {
            log(`Router argument is not object literal at: ${currentPath.join('.')}`);
            return;
          }
          
          // Process each route
          routesArg.getProperties().forEach(prop => {
            if (!Node.isPropertyAssignment(prop)) return;
            
            const routeName = prop.getName();
            const routeValue = prop.getInitializer();
            
            if (!routeValue) return;
            
            if (Node.isIdentifier(routeValue)) {
              const valueText = routeValue.getText();
              
              // Check if it's a procedure
              if (valueText.startsWith('procedure_')) {
                const procedureInfo = procedures.get(valueText);
                if (procedureInfo) {
                  const fullPath = [...currentPath, routeName].join('.');
                  map.set(fullPath, {
                    type: 'procedure',
                    filePath: procedureInfo.filePath,
                    line: procedureInfo.line,
                    position: procedureInfo.position,
                    length: procedureInfo.length,
                    procedureName: valueText
                  });
                  log(`Mapped: api.${fullPath} -> ${path.relative(projectRoot, procedureInfo.filePath)}:${procedureInfo.line}`);
                } else {
                  log(`Procedure not found: ${valueText}`);
                }
              } else if (valueText.endsWith('Router')) {
                // It's a nested router - need to analyze the imported router
                log(`Found nested router: ${valueText} at ${[...currentPath, routeName].join('.')}`);
                
                // Find the import declaration for this router
                const importDecl = mainRouterFile.getImportDeclarations()
                  .find(imp => {
                    const namedImports = imp.getNamedImports();
                    return namedImports.some(ni => ni.getName() === valueText);
                  });
                
                if (importDecl) {
                  const moduleSpecifier = importDecl.getModuleSpecifierValue();
                  const importedFile = importDecl.getModuleSpecifierSourceFile();
                  
                  if (importedFile) {
                    // Find the router in the imported file
                    const nestedRouter = importedFile.getVariableDeclaration(valueText);
                    if (nestedRouter) {
                      log(`Analyzing nested router: ${valueText} from ${path.relative(projectRoot, importedFile.getFilePath())}`);
                      analyzeRouter(nestedRouter, [...currentPath, routeName], depth + 1);
                    } else {
                      log(`Could not find router ${valueText} in imported file`);
                    }
                  } else {
                    log(`Could not resolve import for ${valueText} from ${moduleSpecifier}`);
                  }
                }
              }
            } else if (Node.isCallExpression(routeValue)) {
              // Handle inline procedure definitions (e.g., staffProcedure.input().mutation())
              // Find the base procedure identifier by traversing up the call chain
              let currentNode = routeValue;
              let baseProcedure = null;
              
              while (currentNode) {
                if (Node.isCallExpression(currentNode)) {
                  const expr = currentNode.getExpression();
                  if (Node.isPropertyAccessExpression(expr)) {
                    currentNode = expr.getExpression();
                  } else if (Node.isIdentifier(expr)) {
                    baseProcedure = expr.getText();
                    break;
                  } else {
                    break;
                  }
                } else if (Node.isIdentifier(currentNode)) {
                  baseProcedure = currentNode.getText();
                  break;
                } else {
                  break;
                }
              }
              
              // Check if we found a procedure type
              if (baseProcedure && baseProcedure.endsWith('Procedure')) {
                const fullPath = [...currentPath, routeName].join('.');
                const sourceFile = routeValue.getSourceFile();
                
                // Find the position by looking for the property assignment
                const propAssignment = routeValue.getFirstAncestorByKind(SyntaxKind.PropertyAssignment);
                const position = propAssignment ? propAssignment.getStart() : routeValue.getStart();
                const length = propAssignment ? propAssignment.getEnd() - position : routeValue.getEnd() - routeValue.getStart();
                const lineAndCol = sourceFile.getLineAndColumnAtPos(position);
                
                map.set(fullPath, {
                  type: 'inline-procedure',
                  filePath: sourceFile.getFilePath(),
                  line: lineAndCol.line,
                  position: position,
                  length: length,
                  procedureType: baseProcedure
                });
                log(`Mapped inline procedure: api.${fullPath} -> ${path.relative(projectRoot, sourceFile.getFilePath())}:${lineAndCol.line}`);
              }
            }
          });
        }
        
        // Start analyzing from appRouter
        analyzeRouter(appRouterVariable);
        
        log(`Built navigation map with ${map.size} entries in ${Date.now() - startTime}ms`);
        return map;
        
      } catch (error) {
        log(`Error building navigation map: ${error.message}`);
        console.error(error);
        return new Map();
      }
    }
    
    // Get or build the navigation map
    function getNavigationMap() {
      const now = Date.now();
      if (!navigationMap || now - lastBuildTime > CACHE_DURATION) {
        navigationMap = buildNavigationMap();
        lastBuildTime = now;
      }
      return navigationMap;
    }
    
    // Create proxy for the language service
    const proxy = Object.create(null);
    for (let k of Object.keys(info.languageService)) {
      const x = info.languageService[k];
      proxy[k] = (...args) => x.apply(info.languageService, args);
    }
    
    // Intercept "Go to Definition" (F12 or Cmd+Click)
    proxy.getDefinitionAndBoundSpan = (fileName, position) => {
      try {
        const sourceFile = info.languageService.getProgram().getSourceFile(fileName);
        if (!sourceFile) {
          return info.languageService.getDefinitionAndBoundSpan(fileName, position);
        }
        
        const text = sourceFile.text;
        
        // Find the line containing the position
        const lineStart = text.lastIndexOf('\n', position) + 1;
        const lineEnd = text.indexOf('\n', position);
        const line = text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd);
        
        // Look for TRPC API usage patterns
        // Match patterns like: api.appointments.unsignedAppointments
        const beforeCursor = line.substring(0, position - lineStart);
        const afterCursor = line.substring(position - lineStart);
        
        // Build the complete API path
        let apiPath = '';
        
        // Check if we're in an api.* expression
        const apiMatch = beforeCursor.match(/api\s*\.\s*([\w.]*\w)?$/);
        if (apiMatch) {
          apiPath = apiMatch[1] || '';
          
          // Look forward to complete the path (until we hit .useQuery, .useMutation, etc.)
          const forwardMatch = afterCursor.match(/^([\w.]*?)(?:\s*\.\s*(?:useQuery|useMutation|useSubscription|use)|\s|$)/);
          if (forwardMatch && forwardMatch[1]) {
            apiPath += forwardMatch[1];
          }
          
          // Clean up the path (remove trailing dots, spaces)
          apiPath = apiPath.replace(/\s+/g, '').replace(/\.+$/, '').replace(/^\.+/, '');
          
          if (apiPath) {
            const navMap = getNavigationMap();
            
            // Try to find the exact match or the closest parent
            const pathParts = apiPath.split('.');
            for (let i = pathParts.length; i > 0; i--) {
              const checkPath = pathParts.slice(0, i).join('.');
              const mapping = navMap.get(checkPath);
              
              if (mapping) {
                log(`Navigation found: api.${checkPath} -> ${path.relative(projectRoot, mapping.filePath)}:${mapping.line}`);
                
                // Calculate the text span for the matched part
                const matchedPart = pathParts[i - 1];
                const spanStart = beforeCursor.lastIndexOf(matchedPart) + lineStart;
                
                // Calculate the target position from line number
                let targetStart = 0;
                let targetLength = 100;
                
                try {
                  // Read the target file to calculate exact position
                  const targetFileContent = fs.readFileSync(mapping.filePath, 'utf8');
                  const lines = targetFileContent.split('\n');
                  
                  // Calculate character position from line number
                  for (let lineIdx = 0; lineIdx < mapping.line - 1 && lineIdx < lines.length; lineIdx++) {
                    targetStart += lines[lineIdx].length + 1; // +1 for newline
                  }
                  
                  // For inline procedures, try to find the exact procedure name on the line
                  if (mapping.type === 'inline-procedure' && mapping.line <= lines.length) {
                    const targetLine = lines[mapping.line - 1];
                    const procedureNameMatch = targetLine.match(new RegExp(`\\b${matchedPart}\\s*:`));
                    if (procedureNameMatch && procedureNameMatch.index !== undefined) {
                      targetStart += procedureNameMatch.index;
                      targetLength = procedureNameMatch[0].length;
                    } else {
                      // Fallback: use the whole line
                      targetLength = targetLine.length;
                    }
                  } else if (mapping.type === 'procedure' && mapping.procedureName) {
                    // For exported procedures, find the procedure declaration
                    const targetLine = lines[mapping.line - 1];
                    const procMatch = targetLine.match(new RegExp(`\\b${mapping.procedureName}\\b`));
                    if (procMatch && procMatch.index !== undefined) {
                      targetStart += procMatch.index;
                      targetLength = procMatch[0].length;
                    }
                  }
                } catch (error) {
                  log(`Error calculating position: ${error.message}`);
                  // Fall back to stored position if available
                  if (mapping.position !== undefined) {
                    targetStart = mapping.position;
                    targetLength = mapping.length || 100;
                  }
                }
                
                return {
                  definitions: [{
                    fileName: mapping.filePath,
                    textSpan: {
                      start: targetStart,
                      length: targetLength
                    },
                    kind: ts.ScriptElementKind.functionElement,
                    name: matchedPart,
                    containerKind: ts.ScriptElementKind.moduleElement,
                    containerName: 'TRPC Procedure'
                  }],
                  textSpan: {
                    start: spanStart,
                    length: matchedPart.length
                  }
                };
              }
            }
            
            log(`No navigation found for: api.${apiPath}`);
          }
        }
      } catch (error) {
        log(`Error in getDefinitionAndBoundSpan: ${error.message}`);
      }
      
      // Fall back to default behavior
      return info.languageService.getDefinitionAndBoundSpan(fileName, position);
    };
    
    // Add helpful hover information
    proxy.getQuickInfoAtPosition = (fileName, position) => {
      const prior = info.languageService.getQuickInfoAtPosition(fileName, position);
      
      try {
        const sourceFile = info.languageService.getProgram().getSourceFile(fileName);
        if (sourceFile && prior) {
          const text = sourceFile.text;
          const wordRange = text.substring(Math.max(0, position - 50), Math.min(text.length, position + 50));
          
          // Check if we're hovering over a TRPC call
          if (wordRange.includes('api.') && (wordRange.includes('useQuery') || wordRange.includes('useMutation'))) {
            // Add navigation hint
            if (!prior.documentation) {
              prior.documentation = [];
            }
            prior.documentation.push({
              text: '\n💡 Cmd+Click to navigate to TRPC procedure implementation',
              kind: 'text'
            });
          }
        }
      } catch (error) {
        log(`Error in getQuickInfoAtPosition: ${error.message}`);
      }
      
      return prior;
    };
    
    log("TRPC Navigation Plugin initialized successfully");
    return proxy;
  }
  
  return { create };
}

module.exports = init;